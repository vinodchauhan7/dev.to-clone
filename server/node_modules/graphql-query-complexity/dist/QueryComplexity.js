"use strict";
/**
 * Created by Ivo MeiÃŸner on 28.07.17.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const values_1 = require("graphql/execution/values");
const graphql_1 = require("graphql");
const graphql_2 = require("graphql");
const estimators_1 = require("./estimators");
function queryComplexityMessage(max, actual) {
    return (`The query exceeds the maximum complexity of ${max}. ` +
        `Actual complexity is ${actual}`);
}
function getComplexity(options) {
    const typeInfo = new graphql_1.TypeInfo(options.schema);
    const context = new graphql_1.ValidationContext(options.schema, options.query, typeInfo);
    const visitor = new QueryComplexity(context, {
        // Maximum complexity does not matter since we're only interested in the calculated complexity.
        maximumComplexity: Infinity,
        estimators: options.estimators,
        variables: options.variables
    });
    graphql_1.visit(options.query, graphql_1.visitWithTypeInfo(typeInfo, visitor));
    return visitor.complexity;
}
exports.getComplexity = getComplexity;
class QueryComplexity {
    constructor(context, options) {
        if (!(typeof options.maximumComplexity === 'number' && options.maximumComplexity > 0)) {
            throw new Error('Maximum query complexity must be a positive number');
        }
        this.context = context;
        this.complexity = 0;
        this.options = options;
        if (!options.estimators) {
            console.warn('DEPRECATION WARNING: Estimators should be configured in the queryComplexity options.');
        }
        this.estimators = options.estimators || [
            estimators_1.legacyEstimator(),
            estimators_1.simpleEstimator()
        ];
        this.OperationDefinition = {
            enter: this.onOperationDefinitionEnter,
            leave: this.onOperationDefinitionLeave
        };
    }
    onOperationDefinitionEnter(operation) {
        switch (operation.operation) {
            case 'query':
                this.complexity += this.nodeComplexity(operation, this.context.getSchema().getQueryType());
                break;
            case 'mutation':
                this.complexity += this.nodeComplexity(operation, this.context.getSchema().getMutationType());
                break;
            case 'subscription':
                this.complexity += this.nodeComplexity(operation, this.context.getSchema().getSubscriptionType());
                break;
            default:
                throw new Error(`Query complexity could not be calculated for operation of type ${operation.operation}`);
        }
    }
    onOperationDefinitionLeave() {
        if (this.options.onComplete) {
            this.options.onComplete(this.complexity);
        }
        if (this.complexity > this.options.maximumComplexity) {
            return this.context.reportError(this.createError());
        }
    }
    nodeComplexity(node, typeDef, complexity = 0) {
        if (node.selectionSet) {
            let fields = {};
            if (typeDef instanceof graphql_2.GraphQLObjectType || typeDef instanceof graphql_2.GraphQLInterfaceType) {
                fields = typeDef.getFields();
            }
            return complexity + node.selectionSet.selections.reduce((total, childNode) => {
                let nodeComplexity = 0;
                switch (childNode.kind) {
                    case graphql_2.Kind.FIELD: {
                        const field = fields[childNode.name.value];
                        // Invalid field, should be caught by other validation rules
                        if (!field) {
                            break;
                        }
                        const fieldType = graphql_2.getNamedType(field.type);
                        // Get arguments
                        let args;
                        try {
                            args = values_1.getArgumentValues(field, childNode, this.options.variables || {});
                        }
                        catch (e) {
                            return this.context.reportError(e);
                        }
                        // Check if we have child complexity
                        let childComplexity = 0;
                        if (graphql_1.isCompositeType(fieldType)) {
                            childComplexity = this.nodeComplexity(childNode, fieldType);
                        }
                        // Run estimators one after another and return first valid complexity
                        // score
                        const estimatorArgs = {
                            childComplexity,
                            args,
                            field,
                            type: typeDef
                        };
                        const validScore = this.estimators.find(estimator => {
                            const tmpComplexity = estimator(estimatorArgs);
                            if (typeof tmpComplexity === 'number' && !isNaN(tmpComplexity)) {
                                nodeComplexity = tmpComplexity;
                                return true;
                            }
                            return false;
                        });
                        if (!validScore) {
                            return this.context.reportError(new graphql_2.GraphQLError(`No complexity could be calculated for field ${typeDef.name}.${field.name}. ` +
                                'At least one complexity estimator has to return a complexity score.'));
                        }
                        break;
                    }
                    case graphql_2.Kind.FRAGMENT_SPREAD: {
                        const fragment = this.context.getFragment(childNode.name.value);
                        const fragmentType = graphql_1.assertCompositeType(this.context.getSchema().getType(fragment.typeCondition.name.value));
                        nodeComplexity = this.nodeComplexity(fragment, fragmentType);
                        break;
                    }
                    case graphql_2.Kind.INLINE_FRAGMENT: {
                        let inlineFragmentType = typeDef;
                        if (childNode.typeCondition && childNode.typeCondition.name) {
                            // $FlowFixMe: Not sure why flow thinks this can still be NULL
                            inlineFragmentType = graphql_1.assertCompositeType(this.context.getSchema().getType(childNode.typeCondition.name.value));
                        }
                        nodeComplexity = this.nodeComplexity(childNode, inlineFragmentType);
                        break;
                    }
                    default: {
                        nodeComplexity = this.nodeComplexity(childNode, typeDef);
                        break;
                    }
                }
                return Math.max(nodeComplexity, 0) + total;
            }, complexity);
        }
        return complexity;
    }
    createError() {
        if (typeof this.options.createError === 'function') {
            return this.options.createError(this.options.maximumComplexity, this.complexity);
        }
        return new graphql_2.GraphQLError(queryComplexityMessage(this.options.maximumComplexity, this.complexity));
    }
}
exports.default = QueryComplexity;
//# sourceMappingURL=QueryComplexity.js.map