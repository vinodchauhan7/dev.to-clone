"use strict";
/**
 * Created by Ivo MeiÃŸner on 28.07.17.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const chai_1 = require("chai");
const schema_1 = __importDefault(require("./fixtures/schema"));
const QueryComplexity_1 = __importStar(require("../QueryComplexity"));
const index_1 = require("../index");
describe('QueryComplexity analysis', () => {
    const typeInfo = new graphql_1.TypeInfo(schema_1.default);
    it('should calculate complexity', () => {
        const ast = graphql_1.parse(`
      query {
        variableScalar(count: 10)
      }
    `);
        const complexity = QueryComplexity_1.getComplexity({
            estimators: [
                index_1.simpleEstimator({ defaultComplexity: 1 })
            ],
            schema: schema_1.default,
            query: ast
        });
        chai_1.expect(complexity).to.equal(1);
    });
    it('should calculate complexity with variables', () => {
        const ast = graphql_1.parse(`
      query Q($count: Int) {
        variableScalar(count: $count)
      }
    `);
        const complexity = QueryComplexity_1.getComplexity({
            estimators: [
                index_1.fieldConfigEstimator(),
                index_1.simpleEstimator({ defaultComplexity: 1 })
            ],
            schema: schema_1.default,
            query: ast,
            variables: {
                count: 5,
            },
        });
        chai_1.expect(complexity).to.equal(50);
    });
    it('should not allow negative cost', () => {
        const ast = graphql_1.parse(`
      query {
        variableScalar(count: -100)
      }
    `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: [
                index_1.simpleEstimator({ defaultComplexity: -100 })
            ]
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(visitor.complexity).to.equal(0);
    });
    it('should report error above threshold', () => {
        const ast = graphql_1.parse(`
      query {
        variableScalar(count: 100)
      }
    `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: [
                index_1.fieldConfigEstimator(),
                index_1.simpleEstimator({
                    defaultComplexity: 1
                })
            ]
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(visitor.complexity).to.equal(1000);
        chai_1.expect(context.getErrors().length).to.equal(1);
        chai_1.expect(context.getErrors()[0].message).to.equal('The query exceeds the maximum complexity of 100. Actual complexity is 1000');
    });
    it('should add inline fragments', () => {
        const ast = graphql_1.parse(`
      query {
        variableScalar(count: 5)
        ...on Query {
          scalar
          alias: scalar
        }
      }
    `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: [
                index_1.fieldConfigEstimator(),
                index_1.simpleEstimator({
                    defaultComplexity: 1
                })
            ]
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(visitor.complexity).to.equal(52);
    });
    it('should add fragments', () => {
        const ast = graphql_1.parse(`
      query {
        scalar
        ...QueryFragment
      }

      fragment QueryFragment on Query {
        variableScalar(count: 2)
      }
    `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: [
                index_1.fieldConfigEstimator(),
                index_1.simpleEstimator({
                    defaultComplexity: 1
                })
            ]
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(visitor.complexity).to.equal(21);
    });
    it('should add complexity for union types', () => {
        const ast = graphql_1.parse(`
      query {
        union {
          ...on Item {
            scalar
            complexScalar
          }
        }
      }
    `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: [
                index_1.fieldConfigEstimator(),
                index_1.simpleEstimator({
                    defaultComplexity: 1
                })
            ]
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(visitor.complexity).to.equal(22);
    });
    it('should add complexity for interface types', () => {
        const ast = graphql_1.parse(`
      query {
        interface {
          name
          ...on NameInterface {
            name
          }
        }
      }
    `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: [
                index_1.fieldConfigEstimator(),
                index_1.simpleEstimator({
                    defaultComplexity: 1
                })
            ]
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(visitor.complexity).to.equal(3);
    });
    it('should add complexity for inline fragments without type condition', () => {
        const ast = graphql_1.parse(`
      query {
        interface {
          ... {
            name
          }
        }
      }
    `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: [
                index_1.fieldConfigEstimator(),
                index_1.simpleEstimator({
                    defaultComplexity: 1
                })
            ]
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(visitor.complexity).to.equal(2);
    });
    it('should add complexity for enum types', () => {
        const ast = graphql_1.parse(`
      query {
        enum
      }
    `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: [
                index_1.fieldConfigEstimator(),
                index_1.simpleEstimator({
                    defaultComplexity: 1
                })
            ]
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(visitor.complexity).to.equal(1);
    });
    it('should report error on a missing non-null argument', () => {
        const ast = graphql_1.parse(`
        query {
            requiredArgs
        }
      `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: [
                index_1.fieldConfigEstimator(),
                index_1.simpleEstimator({
                    defaultComplexity: 1
                })
            ]
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(context.getErrors().length).to.equal(1);
        chai_1.expect(context.getErrors()[0].message).to.equal('Argument "count" of required type "Int!" was not provided.');
    });
    it('should report error when no estimator is configured', () => {
        const ast = graphql_1.parse(`
        query {
            scalar
        }
      `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: []
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(context.getErrors().length).to.equal(1);
        chai_1.expect(context.getErrors()[0].message).to.equal('No complexity could be calculated for field Query.scalar. ' +
            'At least one complexity estimator has to return a complexity score.');
    });
    it('should report error when no estimator returns value', () => {
        const ast = graphql_1.parse(`
        query {
            scalar
        }
      `);
        const context = new graphql_1.ValidationContext(schema_1.default, ast, typeInfo);
        const visitor = new QueryComplexity_1.default(context, {
            maximumComplexity: 100,
            estimators: [
                index_1.fieldConfigEstimator()
            ]
        });
        graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, visitor));
        chai_1.expect(context.getErrors().length).to.equal(1);
        chai_1.expect(context.getErrors()[0].message).to.equal('No complexity could be calculated for field Query.scalar. ' +
            'At least one complexity estimator has to return a complexity score.');
    });
});
//# sourceMappingURL=QueryComplexity-test.js.map